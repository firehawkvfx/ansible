# This configures routes for an onsite render node/workstation to allows access to the cloud based NFS share via vpn.

# example local install

# ansible-playbook -i "$TF_VAR_inventory" ansible/node-centos-routes.yaml -v -v --extra-vars "variable_host=workstation.firehawkvfx.com variable_user=deadlineuser hostname=workstation.firehawkvfx.com ansible_become_pass=somepass ansible_ssh_private_key_file=$TF_VAR_onsite_workstation_ssh_key"

- hosts: "{{ variable_host | default('role_node_centos') }}"
  remote_user: "{{ variable_user | default('centos') }}"
  become: true

  vars:
    ansible_become_pass: "{{ user_deadlineuser_pw_local }}"

  tasks:
  - name: test connection and permissions
    debug:
      msg: "connection established"

- hosts: "{{ variable_host | default('role_node_centos') }}"
  remote_user: "{{ variable_user | default('centos') }}"
  become: true

  vars:
    ansible_become_pass: "{{ user_deadlineuser_pw_local }}"
    variable_user: centos
    bastionip: "{{ groups['bastionip'][0] }}"
    houdini_build: "{{ lookup('env','TF_VAR_houdini_build') }}"
    skip_packages: false
    houdini_install_type: node
    ethernet_device: enp9s0f0


  tasks:
  - name: configure routes for an onsite workstation or render node
    debug:
      msg: "configure routes for an onsite workstation or render node"

### configure production routes

  - name: remove previous routes if they exist.  ignore errors if commmand fails - routes probably don't exist.
    shell: |
      ip route del {{ item.subnet }}
    with_items:
      - { subnet: "{{ private_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ public_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ vpn_cidr_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
    when: envtier == 'prod'
    become: yes
    ignore_errors: true
    tags:
      - add-routes

  - name: add routes via vpn
    shell: |
      ip route add {{ item.subnet }} via {{ item.next_hop }} dev {{ ethernet_device }}
    with_items:
      - { subnet: "{{ private_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ public_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ vpn_cidr_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
    when: envtier == 'prod'
    become: yes
    tags:
      - add-routes

  - name: insert/update block in /etc/network/interfaces for routes. configure routes to opposite dev/prod environment so that nodes in both envs can access licence server.  Remove route if it exists and re apply it.
    blockinfile:
      path: "/etc/sysconfig/network-scripts/route-{{ ethernet_device }}"
      create: true
      block: |
        {{ item.subnet }} via {{ item.next_hop }} dev {{ ethernet_device }}
      marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.subnet }}"
    with_items:
      - { subnet: "{{ private_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ public_subnet1_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
      - { subnet: "{{ vpn_cidr_prod }}", next_hop: "{{ openfirehawkserver_prod }}" }
    when: envtier == 'prod'
    become: yes
    tags:
      - add-routes


### configure dev routes
  - name: remove previous routes if they exist.  ignore errors if commmand fails - routes probably don't exist.
    shell: |
      ip route del {{ item.subnet }}
    with_items:
      - { subnet: "{{ private_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ public_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ vpn_cidr_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
    when: envtier == 'dev'
    become: yes
    ignore_errors: true
    tags:
      - add-routes

  - name: add routes via vpn
    shell: |
      ip route add {{ item.subnet }} via {{ item.next_hop }} dev {{ ethernet_device }}
    with_items:
      - { subnet: "{{ private_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ public_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ vpn_cidr_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
    when: envtier == 'dev'
    become: yes
    tags:
      - add-routes

  - name: insert/update block in /etc/sysconfig/network-scripts/route-{{ ethernet_device }} for routes for persistance after reboot
    blockinfile:
      path: "/etc/sysconfig/network-scripts/route-{{ ethernet_device }}"
      create: true
      block: |
        {{ item.subnet }} via {{ item.next_hop }} dev {{ ethernet_device }}
      marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.subnet }}"
    with_items:
      - { subnet: "{{ private_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ public_subnet1_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
      - { subnet: "{{ vpn_cidr_dev }}", next_hop: "{{ openfirehawkserver_dev }}" }
    when: envtier == 'dev'
    become: yes
    tags:
      - add-routes

# this is potentially a disruptive operation if configuring in the middle of work, instead we test just adding the route immediately
  # - name: Restart network service
  #   service:
  #     name: network
  #     state: restarted
  #   become: yes