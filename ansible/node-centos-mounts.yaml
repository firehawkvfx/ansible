# This playbook will validate exports on softnas and mount those with the /etc/fstab file.

# to update a workstation after altering any softnas mounts for the first time use the command -
# ansible-playbook -i ansible/inventory ansible/node-centos-mounts.yaml --extra-vars "variable_host=role_workstation_centos hostname=workstation1.$TF_VAR_public_domain pcoip=true"
# to update a render node, just use -
# ansible-playbook -i ansible/inventory ansible/node-centos-mounts.yaml


# check exports on softnas.
- hosts: role_softnas
  remote_user: centos
  become_user: root
  become: true

  vars:
    # when paths are found at these locations, they will be added to exports.
    exports:
      - path: "/pool1/volume1/"
        pool_name: pool1
        volume_name: volume1
        state: present
        bind: /prod

    import_pool: true

  tasks:
  - name: Check for existance of custom exports in /vagrant/secrets/{{ envtier }}/ebs-volumes/softnas-ebs-volumes.yaml and override default mounts
    stat:
      path: ../secrets/{{ envtier }}/ebs-volumes/softnas-ebs-volumes.yaml
    register: custom_ebs_list
    connection: local

  - name: Override default exports
    include_vars:
      file: ../secrets/{{ envtier }}/ebs-volumes/softnas-ebs-volumes.yaml
    when: custom_ebs_list.stat.exists
    connection: local

  - name: exports
    debug:
      var: item
    with_items: "{{ exports }}"

  # - name: verify exports on softnas to propogate using a regex
  #   shell: |
  #     grep -E "^\/{{ item.pool_name }}\/{{ item.volume_name }}" /etc/exports -o
  #   register: softnas_exports
  #   with_items: "{{ exports }}"

  - name: Check whether /etc/exports contains the mount
    command: grep -E "^\/{{ item.pool_name }}\/{{ item.volume_name }}.*" /etc/exports
    register: presence
    check_mode: no
    ignore_errors: yes
    changed_when: no
    with_items: "{{ exports }}"

  - name: export existance test
    debug:
      var: item
    when: item.rc == 0
    with_items: "{{ presence.results }}"

  - name: export output always
    set_fact: exported_softnas_mounts="{{item}}"
    with_items: "{{ presence.results }}"


  # - name: Greet the world if /tmp/my.conf contains "127.0.0.1"
  #   debug: msg="found"
  #   when: exported_softnas_mounts.rc == 0

  # - name: find exports
  #   lineinfile:
  #     dest: /etc/exports
  #     state: present
  #     regexp: ^\/{{ item.pool_name }}\/{{ item.volume_name }}.*
  #     #regexp: "{{ item.pool_name }}"
  #     line: "{{ item.path }}"
  #   check_mode: yes
  #   register: exported_softnas_mounts
  #   with_items: "{{ exports }}"

  # - name: export output
  #   debug:
  #     var: item
  #   with_items: "{{ exported_softnas_mounts.results }}"

#   - name: ensure after a pool import that the path actually exists.  if so then exports will be updated
#     stat:
#       path: "/{{ item.pool_name }}/{{ item.volume_name }}/"
#     register: volume_mount
#     when: import_pool
#     with_items:
#       - "{{ exports }}"

#   - name: inspect dict of results
#     debug:
#       var: "{{ item }}"
#     with_items: "{{ volume_mount.results }}"
    
#   - name: check is dir
#     debug:
#       msg: "/{{ item.item.pool_name }}/{{ item.item.volume_name }}/ exists on softnas instance"
#     when: item.stat.exists and item.stat.isdir and import_pool
#     with_items: "{{ volume_mount.results }}"


- hosts: "{{ variable_host | default('role_node_centos') }}"
  remote_user: "{{ variable_user | default('centos') }}"
  become: true

  vars:
    softnas_exports: "{{ hostvars[groups['role_softnas'][0]]['presence']['results'] }}"
    hostname: "node1.{{ public_domain }}"
    pcoip: False

  tasks:
  - name: exports to mount to this instance
    debug:
      var: item
    with_items: 
    - "{{ softnas_exports }}"

  - name: create mount directories
    file: 
      path: "{{ item.item.path }}"
      state: directory
      owner: deadlineuser
      group: deadlineuser
    when: item.rc == 0
    with_items: 
    - "{{ softnas_exports }}"

  - name: create bind1 directories
    file: 
      path: "{{ item.item.bind1 }}"
      state: directory
      owner: deadlineuser
      group: deadlineuser
    when: item.item.bind1 and item.rc == 0
    with_items: 
    - "{{ softnas_exports }}"

  - name: create bind2 directories
    file: 
      path: "{{ item.item.bind2 }}"
      state: directory
      owner: deadlineuser
      group: deadlineuser
    when: item.item.bind2 and item.rc == 0
    with_items: 
    - "{{ softnas_exports }}"

  - fail:
      msg: "{{ item.item.path }} is set to be present in exports dict but doesn't exist in /etc/exports"
    when: item.item.state == "present" and item.rc == 1
    with_items:
    - "{{ softnas_exports }}"

  - name: insert/update block in in /etc/fstab for found exports
    blockinfile:
      path: /etc/fstab
      block: |
        {{ groups['role_softnas'][0] }}:{{ item.item.path }} {{ item.item.path }} nfs4 rsize=8192,wsize=8192,timeo=14,intr,_netdev 0 0
      marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.item.path }} PRIMARY MOUNT"
      state: "{{ item.item.state }}"
    with_items:
    - "{{ softnas_exports }}"

  - name: insert/update block in in /etc/fstab for found exports and bind1 points
    blockinfile:
      path: /etc/fstab
      block: |
        {{ item.item.path }} {{ item.item.bind1 }} none defaults,bind,timeo=14 0 0
      marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.item.path }} BIND1"
      state: "{{ item.item.state }}"
    with_items:
    - "{{ softnas_exports }}"

  - name: insert/update block in in /etc/fstab for found exports and bind2 points
    blockinfile:
      path: /etc/fstab
      block: |
        {{ item.item.path }} {{ item.item.bind2 }} none defaults,bind,timeo=14 0 0
      marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.item.path }} BIND2"
      state: "{{ item.item.state }}"
    with_items:
    - "{{ softnas_exports }}"

  - name: mount all changes to fstab
    command: mount -a
    become: true

######

#   # mount softnas and remote nas
#   - name: create mount directories
#     file: 
#       path: "{{ item }}"
#       state: directory
#       owner: deadlineuser
#       group: deadlineuser
#     become: yes
#     with_items:
#       - "{{ softnas1_path_abs }}"
#       - "{{ localnas1_path_abs }}"
#       - "{{ prod_mount_path }}"
#       - "{{ localnas1_remote_mount_path }}"

#   - name: create localnas mount point based on location
#     file: 
#       path: "{{ localnas1_path_abs }}"
#       state: directory
#       owner: deadlineuser
#       group: deadlineuser
#     become: yes

#   - name: insert marker start
#     lineinfile:
#       path: /etc/fstab
#       insertafter: "^#?UUID.*$"

#       line: "# BEGIN ANSIBLE MANAGED BLOCK"
#       backup: yes

#   - name: insert marker end
#     lineinfile:
#       path: /etc/fstab
#       insertafter: "# BEGIN ANSIBLE MANAGED BLOCK"
#       line: "# END ANSIBLE MANAGED BLOCK"
#       create: true
 
#   - name: insert/update block in /etc/fstab
#     blockinfile:
#       path: /etc/fstab
#       backup: yes
#       content: |

#         {{ groups['role_softnas'][0] }}:{{ softnas_mount_source }} {{ softnas1_path_abs }} nfs4 rsize=8192,wsize=8192,timeo=14,intr,_netdev 0 0
#         {{ softnas1_path_abs }} {{ prod_mount_path }} none defaults,bind,timeo=14 0 0

#         # {{ localnas1_private_ip }}:{{ localnas1_mount_path }} {{ localnas1_path_abs }} nfs4 rsize=8192,wsize=8192,timeo=14,intr,_netdev 0 0
#         # {{ localnas1_path_abs }} {{ localnas1_remote_mount_path }} none defaults,bind,timeo=14 0 0
        
#   - name: mount all changes to fstab
#     command: mount -a
#     become: true

#   - stat:
#       path: /var/lib/Thinkbox/Deadline10/deadline.ini
#     register: deadline_ini_file

#   - name: get date
#     shell: |
#       date +"%Y%m%d_%H%M%S"
#     register: current_date

#   - set_fact:
#       backup_dest: "/var/lib/Thinkbox/Deadline10/deadline.bak_{{ current_date.stdout }}"
#     when: deadline_ini_file.stat.exists

#   - debug:
#       msg: "will backup file to {{ backup_dest }}"
#     when: deadline_ini_file.stat.exists

#   - name: move old config to backup.  this prevents old conf settings staying around.
#     command: "mv /var/lib/Thinkbox/Deadline10/deadline.ini {{ backup_dest }}"
#     when: deadline_ini_file.stat.exists

#   - name: install deadline client
#     shell: |
#       cd /home/deadlineuser/Downloads/
#       set -x
#       {{ files_matched.files[0].path }} --mode unattended --debuglevel 2 --prefix {{ deadline_prefix }} --connectiontype Remote --noguimode true --licensemode UsageBased --launcherdaemon true --slavestartup 1 --daemonuser {{ user_deadlineuser_name }} --enabletls true --tlsport 4433 --httpport 8080 --proxyrootdir {{ deadline_proxy_root_dir }} --proxycertificate {{ deadline_proxy_certificate }} --proxycertificatepassword {{ deadline_proxy_certificate_password }}
#     register: deadline_client_install_output_shell
#     become: true
    
#   - name: check deadline client install output
#     debug:
#       msg: "{{ deadline_client_install_output_shell.stdout }}"

#   - name: check /var/lib/Thinkbox/Deadline10/deadline.ini
#     command: cat /var/lib/Thinkbox/Deadline10/deadline.ini 
#     register: deadline_config

#   - debug: msg="{{ deadline_config.stdout }}"
#   - debug: msg="{{ deadline_config.stderr }}"

